# PGP::Sign -- Create a PGP signature for data, securely.  -*- perl -*-
# $Id$
#
# Copyright 1997 by Russ Allbery <rra@stanford.edu>
#
# This program is free software; you can redistribute it and/or modify it
# under the same terms as Perl itself.
#
#                     THIS IS NOT A GENERAL PGP MODULE
#
# For a general PGP module that handles encryption and decryption, key ring
# management, and all of the other wonderful things you want to do with PGP,
# see the PGP module directory on CPAN.  This module is designed to do one
# and only one thing and do it fast, well, and securely -- create and check
# detached signatures for some block of data.
#
# This above all: to thine own self be true,
# And it must follow, as the night the day,
# Thou canst not then be false to any man.
#                               -- William Shakespeare, _Hamlet_

############################################################################
# Modules and declarations
############################################################################

package PGP::Sign;
require 5.003;

use Exporter ();
use FileHandle ();
use IPC::Open3 qw(open3);

@ISA    = qw(Exporter);
@EXPORT = qw(pgp_sign pgp_verify);

use strict;
use vars qw($VERSION @ERROR $ORS $PGP);

($VERSION = (split (' ', q$Revision$ ))[1]) =~ s/\.(\d)$/.0$1/;


############################################################################
# Global variables
############################################################################

# The path to PGP.  This should probably be set when the module is
# installed.  The default is /usr/local/bin/pgp.
$PGP = '/usr/local/bin/pgp';

# It's possible that we may want to send pgp_sign lines that aren't newline
# terminated but want the newlines to be added before the signature is
# generated.  If we allow an output record separator to be set, that will
# let us do that without a high memory cost for a join.  (We actually also
# honor $\, but this is cleaner.  The default is undef.
undef $ORS;

# The text of any errors resulting from the last call to pgp_sign().
@ERROR = ();


############################################################################
# Implementation
############################################################################

# This is our generic "take this data and shove it" routine, used both for
# signature generation and signature checking.  The first argument is the
# file handle to shove all the data into, and the remaining arguments are
# sources of data.  Scalars, references to arrays, references to FileHandle
# or IO::Handle objects, file globs, references to code, and references to
# file globs are all supported as ways to get the data, and at most one line
# at a time is read (cutting down on memory usage).
#
# References to code are an interesting subcase.  A code reference is
# executed repeatedly, whatever it returns being passed to PGP using the ORS
# specified if any, until it returns undef.
sub write_data {
    my $fh = shift;

    # Set our output record separator if one has been requested.
    local $\ = $ORS if defined $ORS;

    # Now, we deal with all of our possible sources of input, one at a time.
    # We really want perl 5.004 here, since we want UNIVERSAL::isa().
    # Unfortunately, we can't rely on 5.004 yet.  *But*, the main reason we
    # want isa() is to handle the various derived IO::Handle classes, and
    # 5.003 should only have FileHandle, so we can hack our way around that.
    # We can't do anything interesting or particularly "cool" with
    # references to references, so those we just print.  (Perl allows
    # circular references, so we can't just dereference references to
    # references until we get something interesting.)  Hashes are treated
    # like arrays.
    my $source;
    for $source (@_) {
        if (ref $source eq 'ARRAY' or ref $source eq 'HASH') {
            for (@$source) { print $fh $_ }
        } elsif (ref $source eq 'GLOB' or ref \$source eq 'GLOB') {
            local $_;
            while (<$source>) { print $fh $_ }
        } elsif (ref $source eq 'SCALAR') {
            print $fh $$source;
        } elsif (ref $source eq 'CODE') {
            local $_;
            while (defined ($_ = &$source ())) { print $fh $_ }
        } elsif (ref $source eq 'REF') {
            print $fh $source;
        } elsif (ref $source)  {
            if ($] > 5.003) {
                if (UNIVERSAL::isa ($source, 'IO::Handle')) {
                    local $_;
                    while (<$source>) { print $fh $_ }
                } else {
                    print $fh $source;
                }
            } else {
                if (ref $source eq 'FileHandle') {
                    local $_;
                    while (<$source>) { print $fh $_ }
                } else {
                    print $fh $source;
                }
            }
        } else {
            print $fh $source;
        }
    }
}


# Create a detached signature for the given data.  The first argument should
# be a key id and the second argument the PGP passphrase, and then all
# remaining arguments are considered to be part of the data to be signed and
# are handed off to write_data().
#
# In a scalar context, the signature is returned as an ASCII-armored block
# with embedded newlines.  In array context, a list consisting of the
# signature and the PGP version number is returned.  Returns undef in the
# event of an error, and the error text is then stored in @PGP::Sign::ERROR.
sub pgp_sign {
    my $keyid = shift;
    my $passphrase = shift;

    # Ignore SIGPIPE, since we're going to be talking to PGP.
    local $SIG{PIPE} = 'IGNORE';

    # We need to send the password to PGP, but we don't want to use either
    # the command line or an environment variable, since both may expose us
    # to snoopers on the system.  So we create a pipe, stick the password in
    # it, and then pass the file descriptor for the password to PGP via an
    # environment variable.
    my $passfh = new FileHandle;
    my $writefh = new FileHandle;
    pipe ($passfh, $writefh);
    print $writefh $passphrase;
    close $writefh;
    local $ENV{PGPPASSFD} = $passfh->fileno ();

    # Fork off a pgp process that we're going to be feeding data to, and
    # tell it to just generate a signature using the given key id and pass
    # phrase.
    my $pgp = new FileHandle;
    my $signature = new FileHandle;
    my $errors = new FileHandle;
    my @command = ($PGP, '+batchmode', '-sabft', '-u', $keyid);
    eval { open3 ($pgp, $signature, $errors, @command) };
    if ($@) {
        @ERROR = ($@, "Execution of pgp failed.\n");
        return undef;
    }

    # Send the rest of the arguments off to write_data().
    unshift (@_, $pgp);
    &write_data;

    # All done.  Close the pipe to PGP, clean up, and see if we succeeded.
    # If not, save the error output and return undef.
    close $pgp;
    if ($? != 0) {
        @ERROR = (<$errors>, "PGP returned exit status $?\n");
        return undef;
    }
    my @signature = <$signature>;
    close $signature;
    close $errors;
    close $passfh;

    # Now, clean up the returned signature and return it, along with the
    # version number if desired.
    1 while ((shift @signature) !~ /-----BEGIN PGP .*-----/);
    my $version;
    while ($signature[0] ne "\n") {
        ($version) = ((shift @signature) =~ /^Version:\s+(.*?)\s*$/);
    }
    shift @signature;
    $#signature = $#signature - 1;
    $signature = join ('', @signature);
    chomp $signature;
    undef @ERROR;
    wantarray ? ($signature, $version) : $signature;
}

# Check a detatched signature for given data.  Takes a signature block (in
# the form of an ASCII-armored string with embedded newlines), a version
# number (which may be undef), and some number of data sources that
# write_data() can handle and returns the key id of the signature, the empty
# string if the signature didn't check, and undef in the event of an error.
# In the event of some sort of an error, we stick the error in @ERROR.
sub pgp_verify {
    my $signature = shift;
    my $version = shift;
    chomp $signature;

    # Ignore SIGPIPE, since we're going to be talking to PGP.
    local $SIG{PIPE} = 'IGNORE';

    # Fork off a pgp process that we're going to be feeding data to, and
    # tell it to just generate a signature using the given key id and pass
    # phrase.
    my $pgp = new FileHandle;
    my $message = new FileHandle;
    my $check = new FileHandle;
    eval { open3 ($pgp, $message, $check, $PGP, '-f') };
    if ($@) {
        @ERROR = ($@, "Execution of pgp failed.\n");
        return undef;
    }

    # Now, send PGP a structured message that looks like a normal PGP
    # message.  It's going to spit the message back at us on $message and
    # the status of the signature on $check.
    print $pgp "-----BEGIN PGP SIGNED MESSAGE-----\n\n";
    unshift (@_, $pgp);
    &write_data;
    print $pgp "\n-----BEGIN PGP SIGNATURE-----\n";
    if (defined $version) { print $pgp "Version: $version\n\n" }
    print $pgp $signature;
    print $pgp "\n-----END PGP SIGNATURE-----\n";

    # All done.  Close the pipe to PGP, clean up, and see if we succeeded.
    # If not, save the error output and return undef.
    close $pgp;
    if ($? != 0) {
        @ERROR = (<$check>, "PGP returned exit status $?\n");
        return undef;
    }

    # We seem to have successfully run pgp.  Check for the message that
    # gives us the key status and return the appropriate thing to our
    # caller.
    local $_;
    my $signer;
    while (<$check>) {
        if (/^Good signature from user(?::\s+(.*)|\s+\"(.*)\"\.)\n$/) {
            $signer = $+;
            last;
        } elsif (/^Bad signature /) {
            last;
        }
    }
    close $message;
    close $check;
    undef @ERROR;
    $signer ? $signer : '';
}


############################################################################
# Module return value and documentation
############################################################################

# Make sure the module returns true.
1;

__DATA__

=head1 NAME

PGP::Sign - Create detached PGP signatures for data, securely

=head1 SYNOPSIS

    use PGP::Sign;
    ($signature, $version) = pgp_sign ($keyid, $passphrase, @data);
    $signer = pgp_verify ($signature, $version, @data);

=head1 DESCRIPTION

This module is designed to do one and only one thing securely and well;
namely, generate and check detached PGP signatures for some arbitrary data.
It doesn't do encryption, it doesn't manage keyrings, it doesn't verify
signatures, it just signs things.  This is ideal for applications like
PGPMoose or control message generation that just need a fast signing
mechanism.

The interface is very simple; just call pgp_sign() with a key ID, a pass
phrase, and some data, or call pgp_verify() with a signature (in the form
generated by pgp_sign()), a version number (which can be undef if you don't
want to give a version), and some data.  The data can be specified in pretty
much any form you can possibly consider data and a few you might not.
Scalars and arrays are passed along to PGP; references to arrays are walked
and passed one element at a time (to avoid making a copy of the array); file
handles, globs, or references to globs are read a line at a time and passed
to PGP; and references to code are even supported (see below).  About the
only thing that we don't handle are references to references (which are just
printed to PGP, which probably isn't what you wanted) and hashes (which are
treated like arrays, which doesn't make a lot of sense).

If you give either function a reference to a sub, it will repeatedly call
that sub, sending the results to PGP to be signed, until the sub returns
undef.  What this lets you do is pass the function an anonymous sub that
walks your internal data and performs some manipulations on it a line at a
time, thus allowing you to sign a slightly modified form of your data
(with initial dashes escaped, for example) without having to use up memory
to make an internal copy of it.

In a scalar context, pgp_sign() returns the signature as an ASCII armored
block with embedded newlines (but no trailing newline).  In a list
context, it returns a two-element list consisting of the signature as
above and the PGP version that signed it.  pgp_sign() will return undef in
the event of any sort of error.

pgp_verify() returns the signer of the message in the case of a good
signature, the empty string in the case of a bad signature, and undef in
the event of some error.

There are three module variables you can set (yes, this is a slightly ugly
interface, and it may be made cleaner in the future):

=over 4

=item $PGP::Sign::PGP

The path to PGP.  This defaults to F</usr/local/bin/pgp>, but may have
been fixed to point at the right place by the module installer during
installation.

=item $PGP::Sign::ORS

Just like C<$\> or C<$ORS> under C<use English>, this is the output record
separator (what's put between each data element, each element of an array,
and each line of a file handle as it's sent to PGP to be signed or
verified).  Depending on what you're doing, it may be convenient to set
this to something like "\n", although in general you should probably avoid
using this feature.

=item @PGP::Sign::ERROR

In the event of an error, this holds the output from PGP or some other
informative error message.

=back

=head1 DIAGNOSTICS

Mostly the contents of @PGP::Sign::ERROR is completely determined by PGP.
The only thing that this module may stick in there is "Execution of PGP
failed" if we couldn't fork off a PGP process and "PGP returned exit
status %d" in the event of a non-zero exit status from PGP.

=head1 CAVEATS

This module uses a pipe and the environment variable PGPPASSFD to give the
pass phrase to PGP, since this is the only secure method (both command
line switches and environment variables can potentially be read by other
users on the same machine using ps).  This requires a version of PGP that
supports that feature, however.  I know for certain that PGP 2.6.2 does,
but I can't be sure about other versions.

This module forks, uses a pipe, and relies on the ability to pass an open
pipe to an exec()ed subprocess.  This may cause portability problems to
certain substandard operating systems.

=head1 AUTHOR

Russ Allbery <rra@stanford.edu>

=head1 HISTORY

Based heavily on work by Andrew Gierth <andrew@erlenstar.demon.co.uk>,
this module came about in the process of implementing PGPMoose signatures
and control message signatures for Usenet.  PGPMoose is the idea of Greg
Rose <ggr@usenix.org>, and signcontrol and pgpverify are the idea of David
Lawrence <tale@isc.org>.

=cut
